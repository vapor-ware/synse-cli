// Package client extends the https://github.com/dghubble/sling package to provide a
// RESTful client to the Synse endpoints. The base url path is constructed
// from the configured Synse url as well as the type and version of the API.
// All new queries within synse should be using an instance of this client.
package client

import (
	"fmt"
	"net/http"
	"time"

	"strings"

	"bytes"
	"encoding/json"

	log "github.com/Sirupsen/logrus"
	"github.com/dghubble/sling"
	"github.com/urfave/cli"
	"github.com/vapor-ware/synse-cli/pkg/config"
	"github.com/vapor-ware/synse-cli/pkg/scheme"
)

const (
	// testBase is the base URI for the 'test' route.
	testBaseURI = "test"

	// versionBaseURI is the base URI for the 'version' route.
	versionBaseURI = "version"

	// configBaseURI is the base URI for the 'config' route.
	configBaseURI = "config"

	// pluginsBaseURI is the base URI for the 'plugins' route.
	pluginsBaseURI = "plugins"

	// scanBaseURI is the base URI for the 'scan' route.
	scanBaseURI = "scan"

	// infoBaseURI is the base URI for the 'info' route.
	infoBaseURI = "info"

	// readBaseURI is the base URI for the 'read' route.
	readBaseURI = "read"

	// transactionBaseURI is the base URI for the 'transaction' route.
	transactionBaseURI = "transaction"

	// writeBaseURI is the base URI for the 'write' route.
	writeBaseURI = "write"
)

// Client is an instance of the synseClient that is used by the CLI to make requests
// against the current active Synse Server host.
var Client = &synseClient{}

// writePost defines the data to POST to the Synse Server "write" route.
type writePost struct {
	Action string `json:"action,omitempty"`
	Data   string `json:"data,omitempty"`
}

// logMiddleware wraps the http.Client object to log messages generated by queries.
type logMiddleware struct {
	c http.Client
}

// Do wraps the http.Request.Do object to log any messages during calls.
func (d logMiddleware) Do(req *http.Request) (*http.Response, error) {
	log.WithFields(log.Fields{
		"method": req.Method,
		"url":    fmt.Sprintf("%v", req.URL),
		// We're not doing anything with headers or forms yet. Once we do, turn
		// these on.
		// ----
		// "header": fmt.Sprintf("%v", req.Header),
		// "form": fmt.Sprintf("%v", req.Form),
	}).Debug("request: start")

	start := time.Now()
	resp, err := d.c.Do(req)
	elapsed := time.Since(start)

	status := ""
	if resp != nil {
		status = resp.Status
	}

	log.WithFields(log.Fields{
		"duration": elapsed,
		"url":      fmt.Sprintf("%v", req.URL),
		"status":   status,
	}).Debug("request: complete")

	return resp, err
}

// newUnversioned generates a new instance of the Client for the un-versioned base endpoint.
func newUnversioned() (*sling.Sling, error) {
	activeHost := config.Config.ActiveHost
	if activeHost == nil {
		return nil, fmt.Errorf("no active host is set - use the 'synse hosts' command to set the active host")
	}
	return sling.New().Doer(&logMiddleware{}).Base(fmt.Sprintf("http://%s/synse/", activeHost.Address)).New(), nil
}

// newVersioned generates a new instance of the Client with the current configuration.
func newVersioned() (*sling.Sling, error) {
	activeHost := config.Config.ActiveHost
	if activeHost == nil {
		return nil, fmt.Errorf("no active host is set - use the 'synse hosts' command to set the active host")
	}
	url, err := constructURL(activeHost.Address)
	if err != nil {
		return nil, err
	}
	return sling.New().Doer(&logMiddleware{}).Base(url).New(), nil
}

// constructURL builds the full url string from the host base, endpoint type
// (Synse), and API version number. Endpoint paths can be extended off of
// this base.
func constructURL(host string) (string, error) {
	version, err := Client.Version()
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("http://%s/synse/%s/", host, version.APIVersion), nil
}

// check is a helper function to check the HTTP response from Synse Server.
// If the request failed with error or returned an error code, it will raise
// an error.
func check(response *http.Response, err error, errorScheme *scheme.Error) error {
	if err != nil {
		return cli.NewExitError(err, 1)
	}

	if response.StatusCode != http.StatusOK {
		errBytes, err := json.Marshal(errorScheme)
		if err != nil {
			return cli.NewExitError(err, 1)
		}

		var errOut bytes.Buffer
		err = json.Indent(&errOut, errBytes, "", "  ")
		if err != nil {
			return cli.NewExitError(err, 1)
		}
		return cli.NewExitError(
			fmt.Sprintf("Synse Server responded with error:\n%v", errOut.String()),
			1,
		)
	}
	return nil
}

// makeURI joins the given components into a string, delimited with '/' which
// can then be used as the URI for API requests.
func makeURI(components ...string) string {
	return strings.Join(components, "/")
}

/*
FIXME: I had these get/post helpers as part of the synseClient, e.g.

func postVersioned(uri string, body interface{}, scheme interface{}) error {
	if c.versionedClient == nil {
		c.versionedClient = newVersioned()
	}
	return check(c.versionedClient.Post(uri).BodyJSON(body).ReceiveSuccess(scheme))
}

but something about how sling was working was weird. It seemed to work fine when
run against an actual live endpoint, but was failing for the tests.
*/

// getUnversioned performs a GET request against the Synse Server unversioned API.
func getUnversioned(uri string, requestScheme interface{}) error {
	errScheme := new(scheme.Error)
	client, err := newUnversioned()
	if err != nil {
		return err
	}
	response, err := client.Get(uri).Receive(requestScheme, errScheme)
	return check(response, err, errScheme)
}

// getVersioned performs a GET request against the Synse Server versioned API.
func getVersioned(uri string, requestScheme interface{}) error {
	errScheme := new(scheme.Error)
	client, err := newVersioned()
	if err != nil {
		return err
	}
	response, err := client.Get(uri).Receive(requestScheme, errScheme)
	return check(response, err, errScheme)
}

// postVersioned performs a POST request against the Sysne Server versioned API.
func postVersioned(uri string, body interface{}, requestScheme interface{}) error {
	errScheme := new(scheme.Error)
	client, err := newVersioned()
	if err != nil {
		return err
	}
	response, err := client.Post(uri).BodyJSON(body).Receive(requestScheme, errScheme)
	return check(response, err, errScheme)
}

// synseClient is a client for making requests against the Synse Server HTTP API.
type synseClient struct{}

// Status gets and parses the response from Synse Server's "test" endpoint.
func (c *synseClient) Status() (*scheme.TestStatus, error) {
	out := &scheme.TestStatus{}
	err := getUnversioned(testBaseURI, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Version gets and parses the response from Synse Server's "version" endpoint.
func (c *synseClient) Version() (*scheme.Version, error) {
	out := &scheme.Version{}
	err := getUnversioned(versionBaseURI, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Config gets and parses the response from Synse Server's "config" endpoint.
func (c *synseClient) Config() (*scheme.Config, error) {
	out := &scheme.Config{}
	err := getVersioned(configBaseURI, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Plugins gets and parses the response from Synse Server's "plugins" endpoint.
func (c *synseClient) Plugins() ([]scheme.Plugin, error) {
	var out []scheme.Plugin
	err := getVersioned(pluginsBaseURI, &out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Scan gets and parses the response from Synse Server's "scan" endpoint.
func (c *synseClient) Scan() (*scheme.ScanResponse, error) {
	out := &scheme.ScanResponse{}
	err := getVersioned(scanBaseURI, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RackInfo gets and parses the response from Synse Server's "info" endpoint for
// rack level requests.
func (c *synseClient) RackInfo(rack string) (*scheme.RackInfo, error) {
	out := &scheme.RackInfo{}
	err := getVersioned(makeURI(infoBaseURI, rack), out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BoardInfo gets and parses the response from Synse Server's "info" endpoint for
// board level requests.
func (c *synseClient) BoardInfo(rack, board string) (*scheme.BoardInfo, error) {
	out := &scheme.BoardInfo{}
	err := getVersioned(makeURI(infoBaseURI, rack, board), out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeviceInfo gets and parses the response from Synse Server's "info" endpoint for
// device level requests.
func (c *synseClient) DeviceInfo(rack, board, device string) (*scheme.DeviceInfo, error) {
	out := &scheme.DeviceInfo{}
	err := getVersioned(makeURI(infoBaseURI, rack, board, device), out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Read gets and parses the response from Synse Server's "read" endpoint.
func (c *synseClient) Read(rack, board, device string) (*scheme.Read, error) {
	out := &scheme.Read{}
	err := getVersioned(makeURI(readBaseURI, rack, board, device), out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Transaction gets and parses the response from Synse Server's "transaction" endpoint.
func (c *synseClient) Transaction(id string) (*scheme.Transaction, error) {
	out := &scheme.Transaction{}
	err := getVersioned(makeURI(transactionBaseURI, id), out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransactionList gets and parses the response from Synse Server's "transaction"
// endpoint for listing all active transactions.
func (c *synseClient) TransactionList() (*[]string, error) {
	out := new([]string)
	err := getVersioned(transactionBaseURI, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Write POSTs data and parses the response from Synse Server's "write" endpoint.
func (c *synseClient) Write(rack, board, device, action, data string) ([]scheme.WriteTransaction, error) {
	out := make([]scheme.WriteTransaction, 0)

	body := &writePost{
		Action: action,
		Data:   data,
	}
	err := postVersioned(makeURI(writeBaseURI, rack, board, device), body, &out)
	if err != nil {
		return nil, err
	}
	return out, nil
}
